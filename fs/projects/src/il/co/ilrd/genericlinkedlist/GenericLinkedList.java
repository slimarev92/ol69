package il.co.ilrd.genericlinkedlist;

import java.util.Iterator;
import java.util.ConcurrentModificationException;

/*
 * @author Sasha Limarev
 * @version 23/09/19
 * Generic singly linked list that can hold objects of single type T. The iterator
 * generated by the list is of the "fail fast" variety.
 */

public class GenericLinkedList<T> implements Iterable<T> {
    private Node<T> head;
    private volatile long modCount;
    
    public GenericLinkedList() {
        head = null;
        modCount = 0;   
    }
    
    public void pushFront(T data) {
        head = new Node<T>(data, head);
        
        increaseModCount();
    }
    
    public T popFront() {
        T ret = head.getData();
        
        head = head.getNext();
        increaseModCount();
        
        return ret;
    }
    
    public int size() {
        Iterator<T> iter = iterator();
        int result = 0;
        
        while(iter.hasNext()) {
            ++result;
            iter.next();
        }
        
        return result;
    }
    
    public boolean isEmpty() {
        return null == head;
    }
    
    public Iterator<T> find(T key) {
        Iterator<T> iter = iterator();
        Iterator<T> prev = iterator();
        
        while(iter.hasNext() && !(iter.next().equals(key))) {
            prev.next();
        }
        
        return prev;
    }
    
    public static <S> GenericLinkedList<S> newReverse(GenericLinkedList<S> gll) {
        GenericLinkedList<S> result = new GenericLinkedList<>();

        for(S curr : gll) {
        	result.pushFront(curr);
        }
        
        return result;
    }
    
    public static <S> GenericLinkedList<S> newMerge(GenericLinkedList<S> gll1,
                                                    GenericLinkedList<S> gll2) {
        GenericLinkedList<S> result = new GenericLinkedList<>();
        
        for(S curr : gll1) {
        	result.pushFront(curr);
        }

        for(S curr : gll2) {
            result.pushFront(curr);
        }
        
        return GenericLinkedList.newReverse(result);
    }
    
    @Override
    public Iterator<T> iterator() {
        return new GenericLinkedListIterator(head);
    } 
    
    synchronized private void increaseModCount() {
        ++modCount;
    }
    
    private static class Node<T> {
        private T data;
        private Node<T> next;
        
        public Node(T data, Node<T> next) {
            this.data = data;
            this.next = next;
        }
        
        public T getData() {
            return data;
        }
        
        public Node<T> getNext() {
            
            return next;
        }
    } /* class Node<T> */

    private class GenericLinkedListIterator implements Iterator<T> {
        private Node<T> node;
        private final long modCountAtCreation;
        
        public GenericLinkedListIterator(Node<T> node) {
            this.node = node;
            modCountAtCreation = modCount;
        }
        
        @Override
        public boolean hasNext() {
            checkModification();
            
            return null != node;
        }
        
        @Override
        public T next() {
            checkModification();
            
            T ret = node.getData();
            node = node.getNext();
            
            return ret;
        }
        
        private void checkModification() {
            if(modCountAtCreation != modCount) {
                throw new ConcurrentModificationException("List modified during iteration");
            }
        }
    } /* class GenericLinkedListIterator */
} /* class GenericLinkedList */